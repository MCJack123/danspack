if"ä"~="\xE4"then local a=assert(fs.open(shell.getRunningProgram(),"rb"))local b=a.readAll()a.close()return assert(load(b,"@"..shell.getRunningProgram(),nil,_ENV))()end;local c=require"cc.expect"local function d(e,f)for g in fs.combine(f):gmatch("[^/]+")do e=e[g]if e==nil then return nil end end;return e end;local function h(i,j)if#i==0 then return type(j)=="table"and""or j elseif type(j)~="table"then return nil end;local k={}for l,m in ipairs(i)do k[l]=m end;local n=table.remove(k,1)local o={}if j then for p,m in pairs(j)do if p:match("^"..n:gsub("([%%%.])","%%%1"):gsub("%*","%.%*").."$")then o[p]=h(k,m)end end end;return o end;local function q(j,r)r=r or""if j==nil then return{}end;local o={}for p,m in pairs(j)do if type(m)=="string"then table.insert(o,r..p)else for s,t in ipairs(q(m,r..p.."/"))do table.insert(o,t)end end end;return o end;local fs=fs;_G.fs={list=function(f)c(1,f,"string")local e=d(disk,f)if type(e)~="table"then return fs.list(f)end;local o={}for p in pairs(e)do o[#o+1]=p end;local i={}for g in fs.combine(f):gmatch("[^/]+")do i[#i+1]=g end;table.sort(o)return o end,exists=function(f)c(1,f,"string")return d(disk,f)~=nil or fs.exists(f)end,isDir=function(f)c(1,f,"string")local e=d(disk,f)return type(e)=="table"or fs.isDir(f)end,isReadOnly=function(f)c(1,f,"string")return d(disk,f)~=nil or fs.isReadOnly(f)end,getName=fs.getName,getDrive=function(f)c(1,f,"string")if d(disk,f)~=nil then return"mem"end;return fs.getDrive(f)end,getSize=function(f)c(1,f,"string")local e=d(disk,f)if e==nil then return fs.getSize(f)end;if type(e)=="table"then return 0 else return#e end end,getFreeSpace=fs.getFreeSpace,makeDir=fs.makeDir,move=fs.move,copy=fs.copy,delete=fs.delete,combine=fs.combine,open=function(f,u)c(1,f,"string")c(2,u,"string")local e=d(disk,f)if e==nil then return fs.open(f,u)end;if u=="r"then if type(e)~="string"then return nil,"Is a directory"end;local v=e;e=""for s,w in utf8.codes(v)do e=e..(w>255 and"?"or string.char(w))end;e=e:gsub("\r\n","\n")local x=1;local y=false;return{readLine=function(z)if y then error("file is already closed",2)end;if x>#e then return end;local A,B=e:match(z and"([^\n]*\n?)()"or"([^\n]*)\n?()",x)x=A and B or#e+1;return A end,readAll=function()if y then error("file is already closed",2)end;if#e==0 and x==1 then x=2;return""end;if x>#e then return end;local C=x;x=#e+1;return e:sub(C)end,read=function(D)if y then error("file is already closed",2)end;if x>#e then return end;c(1,D,"number","nil")D=D or 1;local C=x;x=x+D;return e:sub(C,x-1)end,close=function()if y then error("file is already closed",2)end;y=true end}elseif u=="w"or u=="a"then return nil,"Permission denied"elseif u=="rb"then if type(e)~="string"then return nil,"Is a directory"end;local x=1;local y=false;return{readLine=function(z)if y then error("file is already closed",2)end;if x>#e then return end;local A,B=e:match(z and"([^\n]*\n?)()"or"([^\n]*)\n?()",x)x=A and B or#e+1;return A end,readAll=function()if y then error("file is already closed",2)end;if#e==0 and x==1 then x=2;return""end;if x>#e then return end;local C=x;x=#e+1;return e:sub(C)end,read=function(D)c(1,D,"number","nil")if y then error("file is already closed",2)end;if x>#e then return end;if D==nil then x=x+1;return e:byte(x-1)else local C=x;x=x+D;return e:sub(C,x-1)end end,close=function()if y then error("file is already closed",2)end;y=true end,seek=function(E,F)if y then error("file is already closed",2)end;c(1,E,"string","nil")c(2,F,"number","nil")E=E or"cur"F=F or 0;if E=="set"then x=F+1 elseif E=="cur"then x=x+F elseif E=="end"then x=#e-F else error("bad argument #1 (invalid option "..E..")",2)end;return x-1 end}elseif u=="wb"or u=="ab"then return nil,"Permission denied"else return nil,"Invalid mode"end end,find=function(G)c(1,G,"string")local i={}for g in G:gmatch("[^/]+")do i[#i+1]=g end;local o=fs.find(G)for s,m in ipairs(q(h(i,disk)))do o[#o+1]=m end;table.sort(o)return o end,getDir=fs.getDir,attributes=function(f)c(1,f,"string")local e=d(disk,f)if not e then return fs.attributes(f)end;return{size=type(e)=="table"and 0 or#e,isDir=type(e)=="table",isReadOnly=false,created=0,modified=0}end,getCapacity=fs.getCapacity,isDriveRoot=fs.isDriveRoot}local H=shell.dir()shell.setDir("/")local I,J=pcall(shell.run,"/init.lua")_G.fs=fs;shell.setDir(H)if not I then printError(J)end
