if"ä"~="\xE4"then local a=assert(fs.open(shell.getRunningProgram(),"rb"))local b=a.readAll()a.close()return assert(load(b,"@"..shell.getRunningProgram(),nil,_ENV))()end;if#disk~=size then error("File corrupted (expected "..size..", got "..#disk..")")end;local c=require"cc.expect"local d,e,f,g,h,i,j,k,l,m=bit32.band,bit32.rshift,bit32.lshift,bit32.bor,math.frexp,math.max,math.floor,table.sort,table.concat,string.char;local function n(o)local p,q=h(o)return q-1 end;local function r(o)return o==0 and 0 or 2^(o-1)end;local s,t,u={R=9},{R=5},{16,17,18}for v=0,143 do s[v+1]={v,2}end;for v=144,255 do s[v+1]={v,1}end;for v=256,279 do s[v+1]={v,4}end;for v=280,287 do s[v+1]={v,2}end;for v=0,31 do t[v+1]={v,1}end;for v=0,7 do u[#u+1],u[#u+2]=(8-v)%8,8+v end;local function w(x)local y,z,A=0,0,1;local function B(o)if not o then o=z%8 end;if o==0 then return 0 end;while z<o do A,z,y=A+1,z+8,f(y,8)+x:byte(A)end;local C=d(e(y,z-o),2^o-1)z=z-o;return C end;return B end;local function D(E)local F,G=E.R,2^E.R;local H,I,J,K,L=0,0.625*G+3,{R=F},{},{}for v=1,#E do local M=E[v]K[M[1]]=M[2]for p=1,M[2]do H,L[H]=(H+I)%G,M[1]end end;for H=0,G-1 do local N=L[H]local O={s=N,n=F-n(K[N])}O.X,J[H],K[N]=f(K[N],O.n)-G,O,1+K[N]end;return J end;local function P(B,Q,J,R)local H,S,v,C=B(J.R),R and B(R.R),1,{}while v<=Q do local O=J[H]local N=O.s;if N==256 then return C elseif N>256 then local T=N-257;local U=i(j(T/4)-1,0)if U>0 then T=2+g(B(U),f(d(T,3)+4,U))else T=T+2 end;local V=R[S]local W=V.s;U=i(j(W/2)-1,0)if U>0 then W=1+g(B(U),f(d(W,1)+2,U))else W=W+1 end;for X=0,T do C[v+X]=C[v+X-W]end;v,S=v+T+1,V.X+B(V.n)elseif not R and N>15 then local Y;if N==16 then N,Y=C[v-1],3+B(2)elseif N==17 then N,Y=0,3+B(3)else N,Y=0,11+B(7)end;for X=0,Y-1 do C[v+X]=N end;v=v+Y else C[v],v=N,v+1 end;H=O.X+B(O.n)end;return C end;local function Z(b)local _,C=w(b),""repeat local a0,a1=_(1)==1,_(2)if a1==0 then _()local size=_(16)assert(bit32.bxor(_(16),size)==0xFFFF,"invalid chunk")for p=1,size do C=C..m(_(8))end elseif a1==1 or a1==2 then local E,a2;if a1==1 then E,a2=s,t else local a3,a4,a5,a6=_(5)+257,_(5)+1,_(4)+4,{R=0}for v=1,a5 do local a7=r(_(3))a6.R,a6[v]=a6.R+a7,{u[v],a7}end;a6.R=n(a6.R)k(a6,function(a8,a9)return a8[1]<a9[1]end)local aa=P(_,a3+a4,D(a6))E,a2={R=0},{R=0}for v=1,a3 do E[v]={v-1,r(aa[v])}end;for v=1,a4 do a2[v]={v-1,r(aa[v+a3])}end;for v=1,a3 do E.R=E.R+E[v][2]end;for v=1,a4 do a2.R=a2.R+a2[v][2]end;E.R,a2.R=n(E.R),n(a2.R)end;local ab=P(_,1e10,D(E),D(a2))for v=1,#ab do ab[v]=m(ab[v])end;C=C..l(ab)else error("invalid chunk")end until a0;return C end;local function ac(ad,ae)for M in fs.combine(ae):gmatch("[^/]+")do ad=ad[M]if ad==nil then return nil end end;return ad end;local function af(ag,O)if#ag==0 then return type(O)=="table"and""or O elseif type(O)~="table"then return nil end;local ah={}for v,ai in ipairs(ag)do ah[v]=ai end;local aj=table.remove(ah,1)local C={}if O then for ak,ai in pairs(O)do if ak:match("^"..aj:gsub("([%%%.])","%%%1"):gsub("%*","%.%*").."$")then C[ak]=af(ah,ai)end end end;return C end;local function al(O,am)am=am or""if O==nil then return{}end;local C={}for ak,ai in pairs(O)do if type(ai)=="string"then table.insert(C,am..ak)else for p,an in ipairs(al(ai,am..ak.."/"))do table.insert(C,an)end end end;return C end;local b=Z(disk)disk=textutils.unserialize(b)sleep(0)local fs=fs;_G.fs={list=function(ae)c(1,ae,"string")local ad=ac(disk,ae)if type(ad)~="table"then return fs.list(ae)end;local C={}for ak in pairs(ad)do C[#C+1]=ak end;local ag={}for M in fs.combine(ae):gmatch("[^/]+")do ag[#ag+1]=M end;table.sort(C)return C end,exists=function(ae)c(1,ae,"string")return ac(disk,ae)~=nil or fs.exists(ae)end,isDir=function(ae)c(1,ae,"string")local ad=ac(disk,ae)return type(ad)=="table"or fs.isDir(ae)end,isReadOnly=function(ae)c(1,ae,"string")return ac(disk,ae)~=nil or fs.isReadOnly(ae)end,getName=fs.getName,getDrive=function(ae)c(1,ae,"string")if ac(disk,ae)~=nil then return"mem"end;return fs.getDrive(ae)end,getSize=function(ae)c(1,ae,"string")local ad=ac(disk,ae)if ad==nil then return fs.getSize(ae)end;if type(ad)=="table"then return 0 else return#ad end end,getFreeSpace=fs.getFreeSpace,makeDir=fs.makeDir,move=fs.move,copy=fs.copy,delete=fs.delete,combine=fs.combine,open=function(ae,ao)c(1,ae,"string")c(2,ao,"string")local ad=ac(disk,ae)if ad==nil then return fs.open(ae,ao)end;if ao=="r"then if type(ad)~="string"then return nil,"Is a directory"end;local ap=ad;ad=""for p,a7 in utf8.codes(ap)do ad=ad..(a7>255 and"?"or string.char(a7))end;ad=ad:gsub("\r\n","\n")local A=1;local aq=false;return{readLine=function(ar)if aq then error("file is already closed",2)end;if A>#ad then return end;local x,as=ad:match(ar and"([^\n]*\n?)()"or"([^\n]*)\n?()",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error("file is already closed",2)end;if#ad==0 and A==1 then A=2;return""end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)if aq then error("file is already closed",2)end;if A>#ad then return end;c(1,au,"number","nil")au=au or 1;local at=A;A=A+au;return ad:sub(at,A-1)end,close=function()if aq then error("file is already closed",2)end;aq=true end}elseif ao=="w"or ao=="a"then return nil,"Permission denied"elseif ao=="rb"then if type(ad)~="string"then return nil,"Is a directory"end;local A=1;local aq=false;return{readLine=function(ar)if aq then error("file is already closed",2)end;if A>#ad then return end;local x,as=ad:match(ar and"([^\n]*\n?)()"or"([^\n]*)\n?()",A)A=x and as or#ad+1;return x end,readAll=function()if aq then error("file is already closed",2)end;if#ad==0 and A==1 then A=2;return""end;if A>#ad then return end;local at=A;A=#ad+1;return ad:sub(at)end,read=function(au)c(1,au,"number","nil")if aq then error("file is already closed",2)end;if A>#ad then return end;if au==nil then A=A+1;return ad:byte(A-1)else local at=A;A=A+au;return ad:sub(at,A-1)end end,close=function()if aq then error("file is already closed",2)end;aq=true end,seek=function(av,aw)if aq then error("file is already closed",2)end;c(1,av,"string","nil")c(2,aw,"number","nil")av=av or"cur"aw=aw or 0;if av=="set"then A=aw+1 elseif av=="cur"then A=A+aw elseif av=="end"then A=#ad-aw else error("bad argument #1 (invalid option "..av..")",2)end;return A end}elseif ao=="wb"or ao=="ab"then return nil,"Permission denied"else return nil,"Invalid mode"end end,find=function(ax)c(1,ax,"string")local ag={}for M in ax:gmatch("[^/]+")do ag[#ag+1]=M end;local C=fs.find(ax)for p,ai in ipairs(al(af(ag,disk)))do C[#C+1]=ai end;table.sort(C)return C end,getDir=fs.getDir,attributes=function(ae)c(1,ae,"string")local ad=ac(disk,ae)if not ad then return fs.attributes(ae)end;return{size=type(ad)=="table"and 0 or#ad,isDir=type(ad)=="table",isReadOnly=false,created=0,modified=0}end,getCapacity=fs.getCapacity,isDriveRoot=fs.isDriveRoot}local ay,az=pcall(shell.run,"/init.lua")_G.fs=fs;if not ay then printError(az)end
